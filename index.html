<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUPERSIDER GLOBALLY</title>
    <style>
        body {
            margin: 0;
            background: #1A302F;
            color: #86F5AF;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #globeViz {
            width: 100vw;
            height: 100vh;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 48, 47, 0.9);
            padding: 12px;
            border-radius: 6px;
            max-width: 240px;
            z-index: 100;
            color: white;
        }
        
        .info-panel h2 {
            margin-top: 0;
            color: #86F5AF;
        }
        
        .country-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 48, 47, 0.9);
            padding: 8px;
            border-radius: 6px;
            max-width: 280px;
            max-height: 85vh;
            overflow: hidden;
            z-index: 100;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .country-panel.collapsed {
            max-height: 45px;
            overflow: hidden;
        }
        
        .country-panel h3 {
            margin: 0;
            color: #86F5AF;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: color 0.3s ease;
            font-size: 12px;
            padding: 4px 0;
        }
        
        .country-panel h3:hover {
            color: #DAFF87;
        }
        
        .collapse-arrow {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 14px;
        }
        
        .country-panel.collapsed .collapse-arrow {
            transform: rotate(-90deg);
        }
        
        .category-panel {
            position: absolute;
            top: 20px;
            right: 320px;
            background: rgba(26, 48, 47, 0.9);
            padding: 8px;
            border-radius: 6px;
            max-width: 280px;
            max-height: 85vh;
            overflow-y: auto;
            z-index: 100;
        }
        
        .category-panel h3 {
            margin: 0 0 8px 0;
            color: #86F5AF;
            font-size: 12px;
        }
        
        .category-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            font-size: 11px;
            border: 2px solid transparent;
            line-height: 1.2;
            min-height: 36px;
        }
        
        .category-item:hover {
            background: rgba(134, 245, 175, 0.15);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(134, 245, 175, 0.2);
        }
        
        .category-item.active {
            background: #86F5AF !important;
            color: #1A302F;
            border-color: #DAFF87;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(134, 245, 175, 0.4);
        }
        
        .category-question {
            font-size: 11px;
            flex-grow: 1;
            font-weight: 500;
            line-height: 1.2;
        }
        
        .category-count {
            font-size: 10px;
            color: #86F5AF;
            margin-left: 6px;
            font-weight: bold;
            background: rgba(134, 245, 175, 0.2);
            padding: 2px 5px;
            border-radius: 8px;
            min-width: 18px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .category-item.active .category-count {
            color: #1A302F;
            background: rgba(26, 48, 47, 0.3);
            opacity: 1;
        }
        
        .country-content {
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(0);
            opacity: 1;
        }
        
        .country-panel.collapsed .country-content {
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }
        
        .country-controls {
            margin-bottom: 8px;
        }
        
        .country-controls button {
            background: #86F5AF;
            color: #1A302F;
            border: none;
            padding: 3px 6px;
            margin: 1px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
        }
        
        .country-controls button:hover {
            background: #DAFF87;
        }
        
        .country-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
            max-height: none;
        }
        
        .country-item {
            display: flex;
            align-items: center;
            margin: 1px 0;
            padding: 3px 5px;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            user-select: none;
            font-size: 9px;
        }
        
        .country-item:hover {
            background: rgba(134, 245, 175, 0.2);
        }
        
        .country-item.selected {
            background: #86F5AF !important;
            color: #1A302F;
        }
        
        .country-item.selected .country-count {
            color: #1A302F;
        }
        
        .country-name {
            font-size: 9px;
            flex-grow: 1;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .country-count {
            font-size: 8px;
            color: #86F5AF;
            margin-left: 3px;
            font-weight: bold;
        }
        
        .country-info-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 48, 47, 0.95);
            border: 2px solid #86F5AF;
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
            box-shadow: 0 0 20px rgba(134, 245, 175, 0.5);
            min-width: 300px;
            text-align: center;
        }
        
        .country-info-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .country-info-title {
            font-size: 24px;
            color: #86F5AF;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }
        
        .country-info-count {
            font-size: 18px;
            color: #DAFF87;
            margin-bottom: 15px;
        }
        
        .supersiders-text {
            font-size: 14px;
            color: #DAFF87;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .close-info {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close-info:hover {
            color: #DAFF87;
        }
        
        /* Custom tooltip styles */
        .custom-tooltip {
            position: fixed !important;
            background: rgba(26, 48, 47, 0.98) !important;
            border: 2px solid #86F5AF !important;
            border-radius: 8px;
            padding: 12px 16px;
            color: white !important;
            font-size: 13px;
            white-space: nowrap;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6) !important;
            max-width: 300px;
            z-index: 99999 !important;
            pointer-events: none;
            opacity: 0;
            transition: all 0.15s ease;
            display: none;
            transform: translateZ(0);
            will-change: transform, opacity;
        }
        
        .custom-tooltip.show {
            opacity: 1 !important;
            display: block !important;
            visibility: visible !important;
        }
        
        .tooltip-name {
            color: #86F5AF;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tooltip-count {
            color: #DAFF87;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .tooltip-coords {
            color: rgba(134, 245, 175, 0.7);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
    <script src="//cdn.jsdelivr.net/npm/globe.gl"></script>
</head>

<body>
    <div id="globeViz"></div>
    
    <div class="info-panel">
        <h2>SUPERSIDER GLOBALLY</h2>
        <p>Total countries: <span id="country-count">0</span></p>
        <p>Supersiders selected: <span id="total-count">0</span></p>
        <p><em>Click on points to see details</em></p>
    </div>
    
    <div class="category-panel">
        <h3>Explore Questions</h3>
        <div class="category-list" id="categoryList">
            <!-- Categories will be populated here -->
        </div>
    </div>
    
    <div class="country-panel collapsed" id="countryPanel">
        <h3 onclick="toggleCountryPanel()">
            Countries 
            <span class="collapse-arrow" id="collapseArrow">▼</span>
        </h3>
        <div class="country-content" id="countryContent">
            <div class="country-controls">
                <button onclick="selectAllCountries()">Select All</button>
                <button onclick="deselectAllCountries()">Deselect All</button>
            </div>
            <div class="country-list" id="countryList">
                <!-- Countries will be populated here -->
            </div>
        </div>
    </div>

    <!-- Country Info Overlay -->
    <div class="country-info-overlay" id="countryInfoOverlay">
        <button class="close-info" onclick="hideCountryInfo()">×</button>
        <div class="country-info-title" id="countryInfoTitle">COUNTRY NAME</div>
        <div class="country-info-count" id="countryInfoCount">000</div>
        <div class="supersiders-text">SUPERSIDERS</div>
    </div>

    <!-- Custom Tooltip -->
    <div class="custom-tooltip" id="customTooltip">
        <div class="tooltip-name" id="tooltipName">COUNTRY NAME</div>
        <div class="tooltip-count" id="tooltipCount">000 SUPERSIDERS</div>
        <div class="tooltip-coords" id="tooltipCoords">Lat: 0.00°, Lng: 0.00°</div>
    </div>

    <script>
        // Your country data
        const countryData = [
            { name: "Argentina", count: 86, coordinates: { lat: -34.6037, lng: -58.3816 } },
            { name: "Armenia", count: 3, coordinates: { lat: 40.1792, lng: 44.4991 } },
            { name: "Australia", count: 1, coordinates: { lat: -25.2744, lng: 133.7751 } },
            { name: "Belarus", count: 1, coordinates: { lat: 53.7098, lng: 27.9534 } },
            { name: "Bosnia & Herzegovina", count: 4, coordinates: { lat: 43.9159, lng: 17.6791 } },
            { name: "Brazil", count: 82, coordinates: { lat: -14.2350, lng: -51.9253 } },
            { name: "Bulgaria", count: 1, coordinates: { lat: 42.7339, lng: 25.4858 } },
            { name: "Canada", count: 16, coordinates: { lat: 56.1304, lng: -106.3468 } },
            { name: "Colombia", count: 67, coordinates: { lat: 4.5709, lng: -74.2973 } },
            { name: "Costa Rica", count: 15, coordinates: { lat: 9.7489, lng: -83.7534 } },
            { name: "Croatia", count: 1, coordinates: { lat: 45.1000, lng: 15.2000 } },
            { name: "Cyprus", count: 1, coordinates: { lat: 35.1264, lng: 33.4299 } },
            { name: "Czech Republic", count: 1, coordinates: { lat: 49.8175, lng: 15.4730 } },
            { name: "Denmark", count: 1, coordinates: { lat: 56.2639, lng: 9.5018 } },
            { name: "Dominican Republic", count: 6, coordinates: { lat: 18.7357, lng: -70.1627 } },
            { name: "Ecuador", count: 5, coordinates: { lat: -1.8312, lng: -78.1834 } },
            { name: "Egypt", count: 3, coordinates: { lat: 26.0975, lng: 31.2357 } },
            { name: "El Salvador", count: 7, coordinates: { lat: 13.7942, lng: -88.8965 } },
            { name: "France", count: 3, coordinates: { lat: 46.6034, lng: 1.8883 } },
            { name: "Georgia", count: 1, coordinates: { lat: 42.3154, lng: 43.3569 } },
            { name: "Germany", count: 8, coordinates: { lat: 51.1657, lng: 10.4515 } },
            { name: "Ghana", count: 1, coordinates: { lat: 7.9465, lng: -1.0232 } },
            { name: "Greece", count: 6, coordinates: { lat: 39.0742, lng: 21.8243 } },
            { name: "Guatemala", count: 4, coordinates: { lat: 15.7835, lng: -90.2308 } },
            { name: "Honduras", count: 1, coordinates: { lat: 15.2000, lng: -86.2419 } },
            { name: "Hungary", count: 5, coordinates: { lat: 47.1625, lng: 19.5033 } },
            { name: "India", count: 8, coordinates: { lat: 20.5937, lng: 78.9629 } },
            { name: "Indonesia", count: 8, coordinates: { lat: -0.7893, lng: 113.9213 } },
            { name: "Ireland", count: 1, coordinates: { lat: 53.4129, lng: -8.2439 } },
            { name: "Italy", count: 7, coordinates: { lat: 41.8719, lng: 12.5674 } },
            { name: "Jordan", count: 1, coordinates: { lat: 30.5852, lng: 36.2384 } },
            { name: "Kenya", count: 1, coordinates: { lat: -0.0236, lng: 37.9062 } },
            { name: "Latvia", count: 1, coordinates: { lat: 56.8796, lng: 24.6032 } },
            { name: "Lebanon", count: 2, coordinates: { lat: 33.8547, lng: 35.8623 } },
            { name: "Libya", count: 2, coordinates: { lat: 26.3351, lng: 17.2283 } },
            { name: "Lithuania", count: 3, coordinates: { lat: 55.1694, lng: 23.8813 } },
            { name: "Malaysia", count: 3, coordinates: { lat: 4.2105, lng: 101.9758 } },
            { name: "Mauritius", count: 1, coordinates: { lat: -20.3484, lng: 57.5522 } },
            { name: "Mexico", count: 39, coordinates: { lat: 23.6345, lng: -102.5528 } },
            { name: "Netherlands", count: 4, coordinates: { lat: 52.1326, lng: 5.2913 } },
            { name: "Nicaragua", count: 3, coordinates: { lat: 12.2650, lng: -85.2072 } },
            { name: "Nigeria", count: 1, coordinates: { lat: 9.0820, lng: 8.6753 } },
            { name: "North Macedonia", count: 2, coordinates: { lat: 41.6086, lng: 21.7453 } },
            { name: "Norway", count: 7, coordinates: { lat: 60.4720, lng: 8.4689 } },
            { name: "Palestine", count: 1, coordinates: { lat: 31.9522, lng: 35.2332 } },
            { name: "Panama", count: 7, coordinates: { lat: 8.5380, lng: -80.7821 } },
            { name: "Paraguay", count: 1, coordinates: { lat: -23.4425, lng: -58.4438 } },
            { name: "Peru", count: 9, coordinates: { lat: -9.1900, lng: -75.0152 } },
            { name: "Philippines", count: 8, coordinates: { lat: 12.8797, lng: 121.7740 } },
            { name: "Poland", count: 13, coordinates: { lat: 51.9194, lng: 19.1451 } },
            { name: "Portugal", count: 40, coordinates: { lat: 39.3999, lng: -8.2245 } },
            { name: "Romania", count: 7, coordinates: { lat: 45.9432, lng: 24.9668 } },
            { name: "Russian Federation", count: 2, coordinates: { lat: 61.5240, lng: 105.3188 } },
            { name: "Serbia", count: 8, coordinates: { lat: 44.0165, lng: 21.0059 } },
            { name: "Slovenia", count: 1, coordinates: { lat: 46.1512, lng: 14.9955 } },
            { name: "South Africa", count: 139, coordinates: { lat: -30.5595, lng: 22.9375 } },
            { name: "Spain", count: 39, coordinates: { lat: 40.4637, lng: -3.7492 } },
            { name: "Sweden", count: 1, coordinates: { lat: 60.1282, lng: 18.6435 } },
            { name: "Thailand", count: 1, coordinates: { lat: 15.8700, lng: 100.9925 } },
            { name: "Tunisia", count: 2, coordinates: { lat: 33.8869, lng: 9.5375 } },
            { name: "Turkey", count: 2, coordinates: { lat: 38.9637, lng: 35.2433 } },
            { name: "Ukraine", count: 4, coordinates: { lat: 48.3794, lng: 31.1656 } },
            { name: "United Arab Emirates", count: 5, coordinates: { lat: 23.4241, lng: 53.8478 } },
            { name: "United Kingdom", count: 12, coordinates: { lat: 55.3781, lng: -3.4360 } },
            { name: "United States of America (USA)", count: 18, coordinates: { lat: 37.0902, lng: -95.7129 } },
            { name: "Uruguay", count: 9, coordinates: { lat: -32.5228, lng: -55.7658 } },
            { name: "Venezuela", count: 4, coordinates: { lat: 6.4238, lng: -66.5897 } }
        ];

        // Track which countries are enabled
        let enabledCountries = new Set(countryData.map(country => country.name));
        
        // Track active category
        let activeCategory = null;
        
        // Define regional categories with questions
        const categories = {
            'lone_wolf': {
                question: 'Are there lone wolf countries at Superside?',
                countries: countryData.filter(country => country.count === 1).map(country => country.name)
            },
            'latin_america': {
                question: 'How strong is Superside\'s presence in Latin America?',
                countries: ['Argentina', 'Brazil', 'Colombia', 'Costa Rica', 'Dominican Republic', 'Ecuador', 'El Salvador', 'Guatemala', 'Honduras', 'Mexico', 'Nicaragua', 'Panama', 'Paraguay', 'Peru', 'Uruguay', 'Venezuela']
            },
            'europe': {
                question: 'Which European countries have Supersiders?',
                countries: ['Armenia', 'Belarus', 'Bosnia & Herzegovina', 'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'France', 'Georgia', 'Germany', 'Greece', 'Hungary', 'Ireland', 'Italy', 'Latvia', 'Lithuania', 'Netherlands', 'North Macedonia', 'Norway', 'Poland', 'Portugal', 'Romania', 'Russian Federation', 'Serbia', 'Slovenia', 'Spain', 'Sweden', 'Turkey', 'Ukraine', 'United Kingdom']
            },
            'africa': {
                question: 'Is Superside expanding across Africa?',
                countries: ['Egypt', 'Ghana', 'Kenya', 'Libya', 'Mauritius', 'Nigeria', 'South Africa', 'Tunisia']
            }
        };
        
        // Initialize the globe variable
        let myGlobe;

        // Toggle country panel collapse/expand
        function toggleCountryPanel() {
            const panel = document.getElementById('countryPanel');
            const arrow = document.getElementById('collapseArrow');
            
            panel.classList.toggle('collapsed');
            
            // Update arrow rotation
            if (panel.classList.contains('collapsed')) {
                arrow.style.transform = 'rotate(-90deg)';
            } else {
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // Initialize collapsed state
        function initializeUI() {
            const arrow = document.getElementById('collapseArrow');
            // Set initial arrow state for collapsed panel
            arrow.style.transform = 'rotate(-90deg)';
        }

        // Function to animate category selection and zoom to region
        function animateCategorySelection(categoryId, countryNames) {
            console.log('Category selected:', categoryId, 'with countries:', countryNames);
            
            // Define region views for each category
            const regionViews = {
                'latin_america': {
                    lat: -15,      // Center of South America
                    lng: -60,      // Center longitude for South America
                    altitude: 2.2  // Zoomed out view
                },
                'europe': {
                    lat: 54,       // Center of Europe
                    lng: 15,       // Center longitude for Europe
                    altitude: 1.8  // Closer view for Europe (smaller region)
                },
                'africa': {
                    lat: 0,        // Center of Africa
                    lng: 20,       // Center longitude for Africa
                    altitude: 2.0  // Medium zoom for Africa
                },
                'lone_wolf': {
                    lat: 20,       // Global view
                    lng: 0,        // Center of world
                    altitude: 2.5  // Far out view to see all lone wolves
                }
            };
            
            // Get the appropriate view for this category
            const targetView = regionViews[categoryId];
            if (targetView) {
                console.log(`Zooming to ${categoryId} region:`, targetView);
                myGlobe.pointOfView(targetView, 2500); // 2.5 second smooth transition
            }
        }

        // Function to get color based on count
        function getPointColor(count) {
            if (count >= 50) return '#DAFF87'; // High count - Bright Green
            if (count >= 10) return '#86F5AF'; // Medium count - Medium Green
            return '#4A9B5E'; // Low count - Dark Green
        }

        // Function to get point size based on count
        function getPointSize(count) {
            if (count >= 50) return 0.8;
            if (count >= 10) return 0.5;
            return 0.3;
        }

        // Function to calculate distance between two points
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Function to detect if a route should go across the Pacific
        function isTransPacificRoute(startLng, endLng, startLat, endLat) {
            // Define regions
            const isLatinAmerica = (lng) => lng >= -120 && lng <= -30; // Western hemisphere, Americas
            const isAsia = (lng) => lng >= 95 && lng <= 180; // Eastern Asia/Pacific
            const isOceania = (lng) => lng >= 110 && lng <= 180 && endLat >= -50 && endLat <= -10; // Australia/NZ area
            
            // Check if this is a Latin America to Asia/Oceania route
            const fromLatAm = isLatinAmerica(startLng);
            const toAsiaPacific = isAsia(endLng) || isOceania(endLng);
            const fromAsiaPacific = isAsia(startLng) || isOceania(startLng);
            const toLatAm = isLatinAmerica(endLng);
            
            return (fromLatAm && toAsiaPacific) || (fromAsiaPacific && toLatAm);
        }

        // Generate connections between countries
        function generateConnections(enabledCountriesSet = enabledCountries) {
            const connections = [];
            
            // Filter countries to only enabled ones
            const activeCountries = countryData.filter(country => enabledCountriesSet.has(country.name));
            
            // Check if we're in Lone Wolf mode
            const isLoneWolfMode = activeCategory === 'lone_wolf';
            
            // Ensure every country gets at least one connection (especially lone wolves)
            const countryConnections = new Map();
            activeCountries.forEach(country => countryConnections.set(country.name, 0));
            
            // Connect ALL enabled countries to each other with varying probability
            for (let i = 0; i < activeCountries.length; i++) {
                for (let j = i + 1; j < activeCountries.length; j++) {
                    const country1 = activeCountries[i];
                    const country2 = activeCountries[j];
                    
                    const distance = calculateDistance(
                        country1.coordinates.lat, country1.coordinates.lng,
                        country2.coordinates.lat, country2.coordinates.lng
                    );
                    
                    // Create multiple seeds for more variety in connections
                    const seed1 = (country1.name + country2.name).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const seed2 = (country2.name + country1.name).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const seed3 = Math.abs(country1.coordinates.lat * country2.coordinates.lng);
                    const combinedSeed = (seed1 + seed2 + seed3) % 10000;
                    
                    const pseudoRandom = Math.sin(combinedSeed * 0.001) * 10000;
                    const randomValue = Math.abs(pseudoRandom - Math.floor(pseudoRandom));
                    
                    // Reduced base probability for fewer overall connections
                    let probability = 0.08; // Much lower base probability
                    
                    // Special handling for Lone Wolf mode or lone wolf countries
                    if (isLoneWolfMode || (country1.count === 1 || country2.count === 1)) {
                        // Give lone wolves better chances to connect
                        probability = 0.25;
                        
                        // Boost probability if either country has no connections yet
                        if (countryConnections.get(country1.name) === 0 || countryConnections.get(country2.name) === 0) {
                            probability = 0.45;
                        }
                    } else {
                        // Varied probability for non-lone wolves
                        const countFactor = Math.min((country1.count + country2.count) / 300, 0.15); // Reduced factor
                        const distanceFactor = Math.max(0.05, 1 - (distance / 15000)); // Slightly favor closer countries
                        const randomFactor = Math.random() * 0.12; // Reduced randomness
                        
                        probability = 0.05 + countFactor + (distanceFactor * 0.08) + randomFactor;
                        
                        // Boost for countries with few connections
                        if (countryConnections.get(country1.name) < 2 || countryConnections.get(country2.name) < 2) {
                            probability += 0.15;
                        }
                        
                        // Ensure probability stays within bounds
                        probability = Math.min(Math.max(probability, 0.05), 0.35); // Lower max probability
                    }
                    
                    // Add time-based variation for more dynamic connections
                    const timeVariation = Math.sin(Date.now() * 0.0001 + combinedSeed) * 0.05;
                    probability += timeVariation;
                    
                    const shouldConnect = randomValue < probability;
                    
                    if (shouldConnect) {
                        // Check if this should be a trans-Pacific route
                        const isTransPacific = isTransPacificRoute(
                            country1.coordinates.lng, country2.coordinates.lng, 
                            country1.coordinates.lat, country2.coordinates.lat
                        );
                        
                        let startLng = country1.coordinates.lng;
                        let endLng = country2.coordinates.lng;
                        
                        // Force trans-Pacific routes to go across the Pacific
                        if (isTransPacific) {
                            // If crossing from Americas to Asia, ensure we go the Pacific way
                            if (startLng < 0 && endLng > 0) {
                                // From Americas (negative lng) to Asia (positive lng) - go east across Pacific
                                if (Math.abs(endLng - startLng) > 180) {
                                    startLng = startLng < -150 ? startLng : startLng - 360;
                                }
                            } else if (startLng > 0 && endLng < 0) {
                                // From Asia (positive lng) to Americas (negative lng) - go west across Pacific
                                if (Math.abs(startLng - endLng) > 180) {
                                    endLng = endLng < -150 ? endLng : endLng - 360;
                                }
                            }
                        }
                        
                        connections.push({
                            startLat: country1.coordinates.lat,
                            startLng: startLng,
                            endLat: country2.coordinates.lat,
                            endLng: endLng,
                            startCountry: country1.name,
                            endCountry: country2.name,
                            startCount: country1.count,
                            endCount: country2.count,
                            distance: distance
                        });
                        
                        // Track connections for each country
                        countryConnections.set(country1.name, countryConnections.get(country1.name) + 1);
                        countryConnections.set(country2.name, countryConnections.get(country2.name) + 1);
                    }
                }
            }
            
            // Ensure isolated countries (especially lone wolves) get at least one connection
            const isolatedCountries = activeCountries.filter(country => countryConnections.get(country.name) === 0);
            isolatedCountries.forEach(isolatedCountry => {
                // Find a random partner for isolated countries
                const potentialPartners = activeCountries.filter(country => country.name !== isolatedCountry.name);
                if (potentialPartners.length > 0) {
                    const randomIndex = Math.floor(Math.random() * potentialPartners.length);
                    const partner = potentialPartners[randomIndex];
                    
                    connections.push({
                        startLat: isolatedCountry.coordinates.lat,
                        startLng: isolatedCountry.coordinates.lng,
                        endLat: partner.coordinates.lat,
                        endLng: partner.coordinates.lng,
                        startCountry: isolatedCountry.name,
                        endCountry: partner.name,
                        startCount: isolatedCountry.count,
                        endCount: partner.count,
                        distance: calculateDistance(
                            isolatedCountry.coordinates.lat, isolatedCountry.coordinates.lng,
                            partner.coordinates.lat, partner.coordinates.lng
                        )
                    });
                }
            });
            
            console.log(`Generated ${connections.length} connections for ${activeCountries.length} countries`);
            console.log(`Isolated countries that got forced connections: ${isolatedCountries.length}`);
            return connections;
        }

        // Generate the connections
        let connections = generateConnections();

        // Functions to show/hide country info overlay
        function showCountryInfo(country) {
            const overlay = document.getElementById('countryInfoOverlay');
            const title = document.getElementById('countryInfoTitle');
            const count = document.getElementById('countryInfoCount');
            
            title.textContent = country.name.toUpperCase();
            count.textContent = country.count.toString();
            
            overlay.classList.add('show');
            
            // Auto-hide after 2 seconds (reduced from 4)
            setTimeout(() => {
                hideCountryInfo();
            }, 2000);
        }
        
        function hideCountryInfo() {
            const overlay = document.getElementById('countryInfoOverlay');
            overlay.classList.remove('show');
        }
        
        // Make hideCountryInfo global for onclick handler
        window.hideCountryInfo = hideCountryInfo;

        // Functions for category panel management
        function populateCategoryList() {
            const categoryList = document.getElementById('categoryList');
            categoryList.innerHTML = '';
            
            Object.entries(categories).forEach(([categoryId, categoryData]) => {
                const categoryItem = document.createElement('div');
                categoryItem.className = 'category-item';
                
                // Add active class if this category is currently active
                if (activeCategory === categoryId) {
                    categoryItem.classList.add('active');
                }
                
                // Click handler for the entire item
                categoryItem.addEventListener('click', (e) => {
                    // Deactivate other categories
                    document.querySelectorAll('.category-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    
                    if (activeCategory === categoryId) {
                        // If clicking the same category, deactivate it
                        activeCategory = null;
                    } else {
                        // Activate this category
                        activeCategory = categoryId;
                        categoryItem.classList.add('active');
                        
                        // Select only countries from this category
                        const validCountries = categoryData.countries.filter(countryName => 
                            countryData.some(country => country.name === countryName)
                        );
                        enabledCountries = new Set(validCountries);
                        
                        // Animate category selection with region zoom
                        animateCategorySelection(categoryId, validCountries);
                    }
                    
                    populateCategoryList();
                    populateCountryList();
                    updateVisualization();
                });
                
                const questionSpan = document.createElement('span');
                questionSpan.className = 'category-question';
                questionSpan.textContent = categoryData.question;
                
                const countSpan = document.createElement('span');
                countSpan.className = 'category-count';
                const validCountries = categoryData.countries.filter(countryName => 
                    countryData.some(country => country.name === countryName)
                );
                countSpan.textContent = validCountries.length;
                
                categoryItem.appendChild(questionSpan);
                categoryItem.appendChild(countSpan);
                
                categoryList.appendChild(categoryItem);
            });
        }

        // Functions for country panel management
        function populateCountryList() {
            const countryList = document.getElementById('countryList');
            countryList.innerHTML = '';
            
            // Sort countries by count (descending)
            const sortedCountries = [...countryData].sort((a, b) => b.count - a.count);
            
            sortedCountries.forEach(country => {
                const countryItem = document.createElement('div');
                countryItem.className = 'country-item';
                
                // Add selected class if country is enabled
                if (enabledCountries.has(country.name)) {
                    countryItem.classList.add('selected');
                }
                
                // Click handler for the entire item
                countryItem.addEventListener('click', (e) => {
                    // Deactivate any active category when manually selecting countries
                    if (activeCategory) {
                        activeCategory = null;
                        populateCategoryList();
                    }
                    
                    if (enabledCountries.has(country.name)) {
                        enabledCountries.delete(country.name);
                        countryItem.classList.remove('selected');
                    } else {
                        enabledCountries.add(country.name);
                        countryItem.classList.add('selected');
                        
                        // Show country info overlay
                        showCountryInfo(country);
                        
                        // Focus on the country with smooth zoom
                        myGlobe.pointOfView({
                            lat: country.coordinates.lat,
                            lng: country.coordinates.lng,
                            altitude: 1.2
                        }, 2000);
                    }
                    
                    // Auto-update is always enabled now
                    updateVisualization();
                });
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'country-name';
                nameSpan.textContent = country.name;
                
                const countSpan = document.createElement('span');
                countSpan.className = 'country-count';
                countSpan.textContent = `(${country.count})`;
                
                countryItem.appendChild(nameSpan);
                countryItem.appendChild(countSpan);
                
                countryList.appendChild(countryItem);
            });
        }
        
        function selectAllCountries() {
            activeCategory = null;
            enabledCountries = new Set(countryData.map(country => country.name));
            populateCategoryList();
            populateCountryList();
            // Auto-update is always enabled now
            updateVisualization();
        }
        
        function deselectAllCountries() {
            activeCategory = null;
            enabledCountries = new Set();
            populateCategoryList();
            populateCountryList();
            // Auto-update is always enabled now
            updateVisualization();
        }
        
        function updateVisualization() {
            // Filter countries and generate new connections
            const enabledCountryData = countryData.filter(country => enabledCountries.has(country.name));
            connections = generateConnections();
            
            // Update globe data
            myGlobe.pointsData(enabledCountryData);
            myGlobe.arcsData(connections);
            
            // Update info panel
            updateInfoPanel();
            
            console.log(`Updated visualization: ${enabledCountryData.length} countries`);
        }
        
        function updateInfoPanel() {
            const enabledCountryData = countryData.filter(country => enabledCountries.has(country.name));
            document.getElementById('country-count').textContent = enabledCountryData.length;
            document.getElementById('total-count').textContent = enabledCountryData.reduce((sum, country) => sum + country.count, 0);
        }

        // Function to get arc color based on connection strength
        function getArcColor(connection) {
            const avgCount = (connection.startCount + connection.endCount) / 2;
            const opacity = Math.min(0.3, avgCount / 200); // Reduced opacity significantly
            
            if (avgCount >= 50) return [`rgba(218, 255, 135, ${opacity})`, `rgba(218, 255, 135, ${opacity * 1.5})`]; // Bright Green
            if (avgCount >= 20) return [`rgba(134, 245, 175, ${opacity})`, `rgba(134, 245, 175, ${opacity * 1.5})`]; // Medium Green
            return [`rgba(74, 155, 94, ${opacity})`, `rgba(74, 155, 94, ${opacity * 1.5})`]; // Dark Green
        }

        // Initialize the globe
        myGlobe = new Globe(document.getElementById('globeViz'))
            .globeImageUrl('https://upload.wikimedia.org/wikipedia/commons/b/b3/Solarsystemscope_texture_8k_earth_nightmap.jpg')
            .backgroundImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/night-sky.png')
            .pointOfView({ lat: 20, lng: 0, altitude: 2.5 })
            
            // Points configuration
            .pointsData(countryData.filter(country => enabledCountries.has(country.name)))
            .pointLat(d => d.coordinates.lat)
            .pointLng(d => d.coordinates.lng)
            .pointColor(d => getPointColor(d.count))
            .pointAltitude(d => getPointSize(d.count) * 0.2) // Increased altitude for better hover detection
            .pointRadius(d => getPointSize(d.count) * 1.2) // Increased radius for better hover detection
            .pointLabel(d => null) // Disable built-in tooltip completely
            .pointsMerge(false) // Changed to false for better individual point detection
            .pointsTransitionDuration(1000) // Smooth animation for bars
            
            // Arcs configuration (the connections between countries)
            .arcsData(connections)
            .arcStartLat(d => d.startLat)
            .arcStartLng(d => d.startLng)
            .arcEndLat(d => d.endLat)
            .arcEndLng(d => d.endLng)
            .arcColor(d => getArcColor(d))
            .arcAltitude(d => {
                // Calculate dynamic altitude based on distance to ensure arcs always go around the outside
                const distance = d.distance;
                
                // Special handling for trans-Pacific routes (Latin America to Asia)
                const isTransPacific = isTransPacificRoute(d.startLng, d.endLng, d.startLat, d.endLat);
                if (isTransPacific) {
                    return 0.3; // High arc for trans-Pacific routes
                }
                
                // For long distances (like Germany-Argentina), use higher altitude
                // For short distances, use lower altitude
                if (distance > 10000) return 0.4; // Very long distances - high arc
                if (distance > 5000) return 0.25;  // Long distances - medium arc
                if (distance > 2000) return 0.15;  // Medium distances - low-medium arc
                return 0.08; // Short distances - low arc
            })
            .arcCurveResolution(64) // Higher resolution for smoother curves
            .arcCircularResolution(6) // Better circular resolution for trans-Pacific routes
            .arcStroke(0.2) // Very thin lines for all connections
            .arcDashLength(0.25)
            .arcDashGap(1)
            .arcDashInitialGap(() => Math.random())
            .arcDashAnimateTime(3000)
            .arcsTransitionDuration(1000)
            
            .enablePointerInteraction(true);

        // Removed pulsing animation - bars are now fixed height

        // Initialize the interface
        populateCategoryList();
        populateCountryList();
        updateInfoPanel();
        initializeUI();

        // Make functions global for onclick handlers
        window.selectAllCountries = selectAllCountries;
        window.deselectAllCountries = deselectAllCountries;
        window.updateVisualization = updateVisualization;
        window.toggleCountryPanel = toggleCountryPanel;

        // Debug: Test tooltip on page load
        setTimeout(() => {
            const tooltip = document.getElementById('customTooltip');
            console.log('Testing tooltip visibility...');
            tooltip.style.display = 'block';
            tooltip.style.position = 'fixed';
            tooltip.style.left = '100px';
            tooltip.style.top = '100px';
            tooltip.style.opacity = '1';
            tooltip.style.zIndex = '99999';
            tooltip.classList.add('show');
            
            setTimeout(() => {
                tooltip.classList.remove('show');
                tooltip.style.display = 'none';
                tooltip.style.opacity = '0';
            }, 2000);
        }, 1000);

        // Debug: Check if points are being rendered
        setTimeout(() => {
            const pointsData = myGlobe.pointsData();
            console.log('Points data:', pointsData);
            console.log('Number of points:', pointsData.length);
            
            // Force re-register hover events
            console.log('Re-registering hover events...');
            myGlobe.onPointHover((point, prevPoint) => {
                const tooltip = document.getElementById('customTooltip');
                console.log('HOVER EVENT:', { point, prevPoint });
                
                if (point && point.name) {
                    console.log('SHOWING tooltip for:', point.name);
                    
                    // Cancel any pending hide timeout
                    showTooltipImmediate();
                    
                    // Force show tooltip first with all necessary styles
                    tooltip.style.display = 'block';
                    tooltip.style.visibility = 'visible';
                    tooltip.style.opacity = '1';
                    tooltip.style.position = 'fixed';
                    tooltip.style.zIndex = '99999';
                    tooltip.style.pointerEvents = 'none';
                    tooltip.style.background = 'rgba(26, 48, 47, 0.98)';
                    tooltip.style.border = '2px solid #86F5AF';
                    tooltip.style.borderRadius = '8px';
                    tooltip.style.padding = '12px 16px';
                    tooltip.style.color = 'white';
                    
                    // Update tooltip content
                    const nameEl = document.getElementById('tooltipName');
                    const countEl = document.getElementById('tooltipCount');
                    const coordsEl = document.getElementById('tooltipCoords');
                    
                    if (nameEl) nameEl.textContent = point.name.toUpperCase();
                    if (countEl) countEl.textContent = `${point.count} SUPERSIDERS`;
                    if (coordsEl) coordsEl.textContent = `Lat: ${point.coordinates.lat.toFixed(2)}°, Lng: ${point.coordinates.lng.toFixed(2)}°`;
                    
                    // Position tooltip following mouse with offset
                    const offsetX = 25;
                    const offsetY = -40;
                    let x = currentMouseX + offsetX;
                    let y = currentMouseY + offsetY;
                    
                    // Keep within bounds
                    if (x + 300 > window.innerWidth) x = currentMouseX - 300 - offsetX;
                    if (y < 0) y = currentMouseY + offsetX;
                    
                    tooltip.style.left = x + 'px';
                    tooltip.style.top = y + 'px';
                    tooltip.style.transform = 'none';
                    
                    // Add the show class
                    tooltip.classList.add('show');
                    
                    console.log('Tooltip styles applied and should be visible');
                } else {
                    console.log('HIDING tooltip with delay');
                    // Hide tooltip with delay instead of immediately
                    hideTooltipDelayed();
                }
            });
        }, 2000);

        // Add click interaction for points
        myGlobe.onPointClick((point, event) => {
            console.log('Clicked country:', point.name, 'Count:', point.count);
            
            // Show country info overlay
            showCountryInfo(point);
            
            // Center the globe on the clicked point
            myGlobe.pointOfView({
                lat: point.coordinates.lat,
                lng: point.coordinates.lng,
                altitude: 1.5
            }, 1000);
        });

        // Add hover interaction for points
        myGlobe.onPointHover((point, prevPoint) => {
            const tooltip = document.getElementById('customTooltip');
            console.log('onPointHover triggered', { point, prevPoint });
            
            if (point && point.name) {
                console.log('SHOWING tooltip for:', point.name);
                
                // Cancel any pending hide timeout
                showTooltipImmediate();
                
                // Force show tooltip first with all necessary styles
                tooltip.style.display = 'block';
                tooltip.style.visibility = 'visible';
                tooltip.style.opacity = '1';
                tooltip.style.position = 'fixed';
                tooltip.style.zIndex = '99999';
                tooltip.style.pointerEvents = 'none';
                tooltip.style.background = 'rgba(26, 48, 47, 0.98)';
                tooltip.style.border = '2px solid #86F5AF';
                tooltip.style.borderRadius = '8px';
                tooltip.style.padding = '12px 16px';
                tooltip.style.color = 'white';
                
                // Update tooltip content
                const nameEl = document.getElementById('tooltipName');
                const countEl = document.getElementById('tooltipCount');
                const coordsEl = document.getElementById('tooltipCoords');
                
                if (nameEl) nameEl.textContent = point.name.toUpperCase();
                if (countEl) countEl.textContent = `${point.count} SUPERSIDERS`;
                if (coordsEl) coordsEl.textContent = `Lat: ${point.coordinates.lat.toFixed(2)}°, Lng: ${point.coordinates.lng.toFixed(2)}°`;
                
                // Position tooltip following mouse with offset
                const offsetX = 25;
                const offsetY = -40;
                let x = currentMouseX + offsetX;
                let y = currentMouseY + offsetY;
                
                // Keep within bounds
                if (x + 300 > window.innerWidth) x = currentMouseX - 300 - offsetX;
                if (y < 0) y = currentMouseY + offsetX;
                
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
                tooltip.style.transform = 'none';
                
                // Add the show class
                tooltip.classList.add('show');
                
                console.log('Tooltip styles applied and should be visible');
            } else {
                console.log('HIDING tooltip with delay');
                // Hide tooltip with delay instead of immediately
                hideTooltipDelayed();
            }
        });
        
        // Track mouse position for better tooltip positioning
        let currentMouseX = 0;
        let currentMouseY = 0;
        let isTooltipVisible = false;
        let tooltipTimeout = null; // Add timeout for delayed hiding
        
        // Function to hide tooltip with delay
        function hideTooltipDelayed() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
            }
            tooltipTimeout = setTimeout(() => {
                const tooltip = document.getElementById('customTooltip');
                tooltip.classList.remove('show');
                tooltip.style.display = 'none';
                tooltip.style.opacity = '0';
                tooltip.style.visibility = 'hidden';
                console.log('Tooltip hidden after delay');
            }, 1000); // 1 second delay
        }
        
        // Function to show tooltip immediately
        function showTooltipImmediate() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
        }
        
        document.addEventListener('mousemove', (e) => {
            currentMouseX = e.clientX;
            currentMouseY = e.clientY;
            
            const tooltip = document.getElementById('customTooltip');
            if (tooltip && tooltip.classList.contains('show')) {
                // Add some offset to avoid cursor blocking the tooltip
                const offsetX = 25;
                const offsetY = -40;
                
                let x = currentMouseX + offsetX;
                let y = currentMouseY + offsetY;
                
                // Keep tooltip within viewport bounds
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const tooltipWidth = 300; // estimated width
                const tooltipHeight = 100; // estimated height
                
                if (x + tooltipWidth > viewportWidth) {
                    x = currentMouseX - tooltipWidth - offsetX;
                }
                if (y < 0) {
                    y = currentMouseY + offsetX;
                }
                if (y + tooltipHeight > viewportHeight) {
                    y = currentMouseY - tooltipHeight - offsetX;
                }
                
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }
        });

        // Alternative hover detection using raycasting
        document.getElementById('globeViz').addEventListener('mousemove', (event) => {
            // This is a backup hover detection method
            console.log('Mouse moving over globe area');
        });

        // Add click interaction for arcs
        myGlobe.onArcClick((arc, event) => {
            console.log('Clicked connection:', arc.startCountry, '↔', arc.endCountry);
            // Center the globe between the two connected countries
            const midLat = (arc.startLat + arc.endLat) / 2;
            const midLng = (arc.startLng + arc.endLng) / 2;
            myGlobe.pointOfView({
                lat: midLat,
                lng: midLng,
                altitude: 2.0
            }, 1000);
        });

        // Add some atmospheric effects
        myGlobe.atmosphereAltitude(0.25);
        myGlobe.atmosphereColor('lightskyblue');

        // Auto-rotate the globe slowly
        myGlobe.controls().autoRotate = true;
        myGlobe.controls().autoRotateSpeed = 0.125; // Reduced from 0.25 to half speed
        
        // Regenerate connections periodically for more dynamic visualization
        setInterval(() => {
            if (enabledCountries.size > 0) {
                connections = generateConnections();
                myGlobe.arcsData(connections);
                console.log('Connections regenerated automatically');
            }
        }, 8000); // Regenerate every 8 seconds (slower regeneration for fewer but more varied connections)
    </script>
</body>
</html>
